module Main where

-- Все необходимые импорты, список бывает достаточно большой ^_^
-- Тут вместо того, чтобы объяснять что и зачем нужно я сделаю
-- явное импортирование
import Data.Conduit.Network  (serverSettings)
import Data.Monoid ((<>))
import Data.String (fromString)
-- Импортирование библиотеки для разбора опций командной строки,
-- достаточно удобная, хотя некоторые предпочитают docopt, не знаю почему
import Options.Applicative
-- И загружаем нашу серверную логику из библиотеки.
import Server

-- | Тип описывающий конфиругацию исполняемого файла.
--
-- INFO: Strict field.
-- Смешной знак @!@ который тут есть говорит о тому, что поле должно быть
-- строгим, (как в привычных ЯП). Грубо говоря Rule of thumb то, что в
-- структурах которые не являются контрольными, т.е. не определяют control flow
-- программы, все поля должны быть строгими. Контрольные структуры это не, по
-- которым мы проходим при выполнении программы, можно сказать, что они как
-- итераторы, но это не так, т.к. дерево - это не лучший итератор, но хорошая
-- контрольная структура.
data Config = Config
  { cfgPort :: !Int
  , cfgHost :: !String
  }

-- | Функция которая декларативно описывает разбор конфигурации.
--
-- INFO: Applicative.
-- тут мы видим стандартный паттерн @f <$> a <*> b <*> c@ это применение
-- аппликативного функтора, чтобы не вдаваться в подробности, опишу тут идею
-- как это работает. Пусть у нас есть некоторый контекст, со своим состоянием,
-- или особенностями (напр. список, парсер, билдер, IO, STM), и действия в
-- этом контексте @a,b,c@. Тогда мы можем применить чистую функцию к результатам
-- этих действией. Т.е. функция 'Config' это @Config :: Int -> String -> Config@,
-- мы можем применить её к операциям @a :: Parser Int@ и @b :: Parser String@ и
-- получить @Parser Config@. Т.о. собрать из блоков целое. В этом проекте такое
-- будет употребяться повсеместно, так что стоит привыкнуть.
--
-- Аналогия из "обычного языка":
--
-- @
-- config = new Parser().function(Config).add(a).add(b).apply();
-- @
--
-- INFO: Monoid
-- @(<>) :: a -> a -> a@ - позволяет собирать из 2ух структур более полную,
-- для неё должны выполняться хорошие математические законы, позволяющие оптимизации.
-- Часто используется для построения новой структуры.
--
-- Аналогия из "обычного языка":
--
-- @
-- value = new Builder().long("port").metavar("PORT").short('p').value(9999).build();
-- @
--
irc :: Parser Config
irc = Config <$> option auto                    -- Получить значение типа который вывелся
                   ( long "port"                -- опция @--port@
                   <> metavar "PORT"            -- подстановка при выводе help
                   <> short 'p'                 -- опция @-p@
                   <> value 9999                -- значение по умолчанию
                   <> help "Application port")  -- строка подсказки
             <*> strOption
                   ( long "host"
                   <> short 'h'
                   <> metavar "HOST"
                   <> value "localhost"
                   <> help "Application host")

main :: IO ()
main = execParser opts >>= run where            -- запустить парсер и передать полученное
                                                -- значение в программу, или вывести помощь
                                                -- или сообещение об ошибке пользователю
  run :: Config -> IO ()
  run (Config port host) =
    server $ serverSettings port (fromString host)  -- запускаем наш сервер
  -- формирование красивых сообщений для --help.
  opts = info (irc <**> helper)
              (fullDesc
               <> progDesc "simple irc server"
               <> header "irc - is a nice thing")
