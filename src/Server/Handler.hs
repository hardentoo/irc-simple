-- Это модуль для обработчиков. Тут уже начинаются интересные моменты.
-- Предполагается, что код будет рабоать с сервером через этот интерфейс
-- который описывает какие возможности есть у пользователя.
-- Я решил продемонтсрировать работу с STM тут, с одной стороны это
-- не полезно для сервера, но с другой дает интересные свойства, которые
-- могут быть нужны в других проектах. Так же демонстрирует то, какие
-- возможности может дать чистота языка.
-- Да, STM такое какое оно здесь работает благодаря чистоте, это значит
-- что мы можем использовать оптимистическую блокировку, и спокойно
-- переигрывать транзакции и использовать полный сабсет языка в них.
--
-- Зачем все это нужно - с транзакциями мы получаем гарантии консистентности,
-- и уменьшение race conduitions. Например:
--
--   1. Вы никогда не получите сообщение от пользователя в канал до того
--      как он вошёл
--
--   2. Если вы видите сообщение, то оно было отправлено всем пользователям
--      которых вы видите на канале
--
--   3. Все пользователи видят все сообщения в однои и том же порядке.
--
-- Тут можно заменить, что я говорию про отправку, а не доставку, с гарантированной
-- доставкой все становится интереснее, но irc не об этом, там даже описанных гарантий,
--
-- INFO В этом модуле мы знакомимся с понятием стека эффектов и тем, как его можно использовать.
-- Отличие от обычных языков, в том, что мы рассматриваем различные возможности не
-- как отдельные компоненты моделируемые объектом, а как слои, например в слое
--
--   @Reader T@ - любое действие может получить доступ к значению T лежищем в окружении
--   @(->) T@   - тоже самое, да просто функция
--   @Writer T@ - все функции могут писать лог, на самом деле это контекст для создания
--     утечек памяти
--   @State T@  - есть доступ к чистому состоянию
--   @STM@      - можно делать STM операции, формирующие транзакцию
--   @IO@       - можно всё!
--   @...@      - и много чего ещё
--
-- Данные слои это не ограничение допустимых операций и система меток (что тоже есть),
-- а наоборот добавление структур позволяющих делать с ними, что-то новое. При этом
-- мы можем складывать слои один с другим формируя стек. например
--
--    @ReaderT Env IO@ - окружение в котором есть доступ до значения типа Env и I/O операции
--
-- Явно использовать стек не всегда удобно, поскольку это дает runtime оверхед да и
-- нужно использовать спец операцию lift, в общем неудобно. Вместо этого можно задавать
-- интерфейсы от слоя и тогда делать один слой предоставляющий разные интерфейсы.
-- А раз можно то будем использовать все! когда что удобнее

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeApplications  #-}
{-# LANGUAGE OverloadedStrings #-}   -- Позволяет использовать синтаксис "fff" для задания
                                     -- значений типов отличных от строк.
{-# LANGUAGE GeneralizedNewtypeDeriving #-}  -- Уменьшаем количество бойлерплейта
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE RankNTypes #-}          -- Ой все, сложно
-- |
-- Модуль для пользовательского обработчика событий, в нём хранится дополнительная
-- информация о состоянии пользователя.
module Server.Handler
  ( Handler(..)
  , RunHandler(..)
  , HandlerState(..)
  , UserState
  , Server.Internal.Message(..)
  , reply
  , unregister
  , Server.Handler.register
  , throwHandler
  , askNickname
  , updateUserChannels
  ) where

-- INFO: Интерфейс, который говорит, что данный стек построен на какой-то базовом контексте,
-- обычно STM или IO. И мы можем операцию из этой базового контекста превратить в операцию
-- в контесте где мы работаем. Такая операция не будет иметь доступа к состоянию нашего конткста
-- Пример:
--
-- @
-- liftBase (readTVar a) :: ReaderT Env STM A
-- @
--
-- Делает из STM операции операцию в нашем контексте.
import           Control.Monad.Base
import           Control.Monad.Reader                -- Интерфейс для Reader
import           Control.Monad.Trans.Resource as Resource
import           Control.Monad.Except                -- Интерфейс для контекста,
                                                     -- который может останавливаться с ошибкой
import           Control.Monad.Trans.Except          -- Реализация слоя для операций с ошибкой/исключением
import           Control.Concurrent.STM              -- STM слой/контекст
import           Data.Set (Set)                      -- Немного структур данных
import qualified Data.Set as Set                     -- Квалифицированный импорт можно использовать методы
                                                     -- как Set.method
import qualified Data.Map as Map
import           Data.Foldable (for_)
import           Protocol.Types                      -- Наши типы и данные
import           Protocol.Errors
import qualified Protocol.Wire as Wire
import qualified Server.Channel as Channel
import           Server.Internal
import           Uni                                 -- ^_^

-- | Состояние обработчика, это то новое состояние, которого нету
-- в обычной работе сервера, и к которому мы получаем доступ, когда
-- вызываем обработчик. Т.о. сам сервер не может в нём копаться и ломать
-- наше состояние, пока мы сами этого не попросили
data HandlerState = HandlerState
 { handlerReply :: Wire.Message -> STM () -- ^ Функция для обратной связи
 , handlerState :: ServerState            -- ^ Доступ к состоянию сервера
 , handlerUser  :: UserState              -- ^ Состояние текущего пользователя
 }

-- | Состояние пользователя. Информация ассоциированная с тредом пользователя.
-- важно, что тут мы используем изменяемые переменные. В принципе все можно бы
-- было выразить через чистый State, но поскольку мы работаем не с чистыми
-- вычислениями и финализация зависит от этих значений, то нам приходится
-- использовать мутабельные переменные, иначе при исключении мы потеряем
-- доступ к контексту.
data UserState = UserState
  { userNickname :: TVar Nickname        -- ^ имя пользователя
  , userChannels :: TVar (Set Channel)   -- ^ список каналов
  }

-- | Контекст в котором ведётся работа, он предоставляет интерфейс к окружению (HandlerState)
--   1. Состояние пользователя
--   2. Состояние сервера
--   3. Возможность общаться с пользователем
--
-- Позволяет описывать возможноые ошибки ExceptT e
--
-- Выполняется в STM
--
-- из него у нас создан стек и нам хочется рассказать, что он обладает описанными выше
-- интерфейсами, что мы делаем через deriving. Как это работает: т.е. это у нас тип
-- обертка 'newtype' а для внутренних типов есть нужные интерфейсы, то мы просто
-- говорим компилятору, примени для необернутого типа, и оберни - дешево и сердито.
--
-- Этот слой постоен поверх серверного слоя и главное что он дает это возможность
-- прямого общения с пользотваелем (reply + ошбики) и имеет состояние пользователя.
newtype Handler e a = Handler { unHandler :: ReaderT HandlerState (ExceptT e STM) a }
  deriving (Functor,Applicative, Monad, MonadBase STM, MonadReader HandlerState, MonadError e)

-- | АААААААААА страшная штука? Так выглядит динамическая диспатчеризация, на самом
-- деле динамическая. Ну обо всем подробнее, так мы храним функцию, которая может
-- исполнять 'Handler', который там передали, причем его тип там заранее (в компайл тайме)
-- не известен, а именно - нам не известен тип ошибки, которые могут возникать.
-- Более того, мы можем выполнять хэндлен разных контекстах (известных в compile time).
--
-- Аналог псевдокод
-- @
-- class Runner<M> {
--   M run(handler : Handler<E instance IsCodeError, ()>) { ... }
-- @
--
-- можно и без этого было обойтись, используя расширяемые исключения, но у меня появился
-- шанс показать динамическую диспетчеризацию. Да и возращение функцонального объекта тоже.
--
-- Использя этот объект мы можем спрятать все приватное состояние в функцию,
-- и позволять пользователю запускать обработчики, при этом не отдавая им информацию
-- о внутренем состоянии. Так же аналог это handle pattern, но мы ж не знаем требований
-- и хотим сделать общий вариант.
newtype RunHandler m = RunHandler {
  runHandler :: forall e. (IsCodeError (Uni e), Monad m)
             => Handler (Uni e) ()
             -> m ()
  }

-- | И у нас есть возможность использовать методы из внутреннего интерфейса
--
-- Этот слой говорит о том, что у нас есть доступ с состоянию сервера и мы можем
-- использять операции из того слоя
instance HasServerState (Handler e) where
  askServerState = asks handlerState

-- | Обновить список каналов пользователя. (Boilderplate!)
--
-- XXX: лично мне не нравится эта штука, я бы лучше сделал явное API
-- в Server.User, которое бы принимало атомарные операции, а не этот
-- @(Set Channel -> Set Channel)@
updateUserChannels :: (Set Channel -> Set Channel) -> Handler e ()
updateUserChannels f = do
  channels <- asks (userChannels . handlerUser)
  liftBase $ modifyTVar channels f -- вот тут мы поднимаем STM в наш Handler

-- | Получить имя пользователя
askNickname :: Handler e Nickname
askNickname = liftBase . readTVar =<< asks (userNickname.handlerUser)

-- | Выкинуть ошибку
throwHandler :: e -> Handler e a
throwHandler e = Handler $ ReaderT $ \_ -> throwE e

-- | Регистрация пользователя в системе.
register
  :: forall m .MonadIO m                                    -- в любом контексте где можно IO
  => ServerState
  -> Nickname
  -> (Wire.Message -> STM ())                               -- уже знакомая функция для отправки
                                                            -- сообщения пользователю
   -- Тут мы возвращаем или ошибку о том, что ник уже используется или
   -- объект, который позволяет исполнять обработчики. В ответ мы возвращаем действие
   -- которое должно быть исполнено, там где пользователь это может сделать
  -> STM (Either NickNameInUse (ResourceT IO (RunHandler m)))
register ss nick call = flip runReaderT ss $ do
  users <- askServerUsers                                  -- Получили список пользователлй
  case Map.lookup nick users of                            -- посмотрели занят ли ник
    Nothing -> lift $ do                                   -- не занят
      state <- UserState <$> newTVar nick                  -- создали новое состояние (комтекст - STM)
                         <*> newTVar Set.empty
      flip runReaderT ss $                                 -- добавили информацию о пользователе
        -- тут интересно, то что мы сохранили новый callback который работает
        -- с серверными сообщениями, т.к. в них есть под инфа о настоящем отправителе
        updateServerUsers $ Map.insert nick (UserInfo $ call .Wire.toMessage)
      -- генерируем ответ
      pure $ Right $ do
        -- Регистрируем финализатор, если тред умрет, то пользователь выйдет
        _ <- Resource.register (atomically $ unregister ss state)
        -- создаем запускатр
        pure $ RunHandler $ \f -> do
                 eresult <- liftIO $ atomically            -- запускаем транзакцию
                   $ runUni                                -- которая вернёт результат или ошибку
                   $ runReaderT (unHandler f) (HandlerState call ss state)
                 case eresult of
                   -- если ошибка, то конвертируем её в сообщение и отправим в сеть
                   Left problem -> liftIO $ atomically $ call $ errorToWire problem
                   Right _ -> pure ()
    Just _  -> pure $ Left $ NickNameInUse nick

-- | пользователь ушёл
unregister :: ServerState
           -> UserState
           -> STM ()
unregister ss state = do
  nick     <- readTVar $ userNickname state
  uch      <- readTVar $ userChannels state
  runReaderT (updateServerUsers $ Map.delete nick) ss   -- убрали из списка
  for_ uch $ \ch -> runUni @[NotOnChannel, NoSuchChannel] $
    flip runReaderT ss $ do
      st <- Channel.get ch
      Channel.partUser st nick (Just "connection closed..") -- послали PART сообщение

-- | Отправить сообщение пользователю вызывающему хендлер. Обычно используется
-- для передачи ответов на сообщения и ошибках.
reply :: Wire.IsMessage a => a -> Handler e ()
reply msg = do
  go <- asks handlerReply
  liftBase $ go $ Wire.toMessage msg
